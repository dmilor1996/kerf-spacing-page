<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Kerf Spacing Calculator - Simplified</title>
  <!-- Use the original Blocklayer CSS for basic styling -->
  <link rel="stylesheet" href="assets/www.blocklayer.com/css/bl4.css">
  <style>
    body { font-family: Verdana, Arial, sans-serif; margin: 20px; }
    .calculator {
      display: flex;
      flex-wrap: wrap;
      gap: 40px;
    }
    .calc-form {
      border: 1px solid #ccc;
      padding: 20px;
      border-radius: 6px;
      width: 320px;
      background-color: #f9f9f9;
    }
    .calc-form label {
      display: block;
      margin-bottom: 8px;
      font-weight: bold;
    }
    .calc-form input[type="number"] {
      width: 100%;
      padding: 6px;
      box-sizing: border-box;
      margin-top: 4px;
    }
    .calc-form input[type="checkbox"] {
      margin-right: 6px;
    }
    .calc-form button {
      margin-top: 12px;
      padding: 8px 14px;
      font-size: 16px;
      border: none;
      border-radius: 4px;
      background-color: #0078d4;
      color: white;
      cursor: pointer;
    }
    .calc-form button:hover {
      background-color: #005fb8;
    }
    .results {
      flex: 1;
      min-width: 280px;
      max-width: 450px;
    }
    .results h3 {
      margin-top: 0;
    }
    .error {
      color: red;
    }
  </style>
</head>
<body>
  <h1>Kerf Spacing Calculator for Bending Wood</h1>
  <div class="calculator">
    <div class="calc-form">
      <label>
        Curve Radius (outside) (mm)
        <input type="number" id="radius" step="0.1" min="1" value="300">
      </label>
      <label>
        Curve Sweep Angle (degrees)
        <input type="number" id="angle" step="0.1" min="1" max="360" value="90">
      </label>
      <label>
        Kerf Width (blade thickness) (mm)
        <input type="number" id="kerf" step="0.01" min="0.1" value="2">
      </label>
      <label>
        Wood Thickness (mm)
        <input type="number" id="thickness" step="0.1" min="1" value="20">
      </label>
      <label>
        Minimum Thickness (mm)
        <input type="number" id="minThick" step="0.1" min="0.1" value="3">
      </label>
      <label>
        <input type="checkbox" id="curveFromEnds">
        Cuts start from board ends
      </label>
      <button id="calculate" type="button">Calculate</button>
      <p id="error" class="error"></p>
    </div>
    <div class="results" id="results">
      <h3>Results</h3>
      <p>Enter values and click <strong>Calculate</strong> to see the kerf spacing results.</p>
    </div>
  </div>
      <!-- Diagram sections: straight and curved representations. Each canvas illustrates the kerf spacing in two different views.
           The first canvas shows a straight (top) view of the board with vertical cut lines and numbering.
           The second canvas shows a curved view of the board with radial cuts and wedge-shaped kerfs. -->
      <div style="margin-top: 30px;" id="diagramContainer">
        <canvas id="straightDiagram" width="800" height="160" style="border:1px solid #ccc; width:100%; max-width:100%; display:block;"></canvas>
        <p style="font-size: 12px; color: #555; margin-top: 4px;">Straight representation: vertical lines denote kerf cuts. Numbers indicate the cut sequence.</p>
        <canvas id="curvedDiagram" width="800" height="300" style="border:1px solid #ccc; width:100%; max-width:100%; display:block;"></canvas>
        <p style="font-size: 12px; color: #555; margin-top: 4px;">Curved representation: the board is bent into an arc; wedge shapes depict the kerf cuts.</p>
      </div>
  <script>
    function calculate() {
      const radius = parseFloat(document.getElementById('radius').value);
      const angle = parseFloat(document.getElementById('angle').value);
      const kerf = parseFloat(document.getElementById('kerf').value);
      const thickness = parseFloat(document.getElementById('thickness').value);
      const minThick = parseFloat(document.getElementById('minThick').value);
      const curveFromEnds = document.getElementById('curveFromEnds').checked;
      const errorElem = document.getElementById('error');
      const resultsElem = document.getElementById('results');
      errorElem.textContent = '';
      resultsElem.innerHTML = '<h3>Results</h3>';
      // Validate inputs
      if (isNaN(radius) || radius <= 0) { errorElem.textContent = 'Please enter a valid curve radius.'; return; }
      if (isNaN(angle) || angle <= 0 || angle > 360) { errorElem.textContent = 'Please enter a sweep angle between 0 and 360 degrees.'; return; }
      if (isNaN(kerf) || kerf <= 0) { errorElem.textContent = 'Please enter a valid kerf width.'; return; }
      if (isNaN(thickness) || thickness <= 0) { errorElem.textContent = 'Please enter a valid wood thickness.'; return; }
      if (isNaN(minThick) || minThick <= 0 || minThick >= thickness/2) { errorElem.textContent = 'Minimum thickness must be positive and less than half the wood thickness.'; return; }
      // Compute outer and inner arc lengths for the given sweep.  The outer arc
      // length is based on the full radius; the inner arc length uses the
      // remaining thickness after the board is removed.  The difference
      // between these lengths represents the length of the board across its
      // thickness and determines how many kerf cuts are needed.
      const outerArcLength = 2 * Math.PI * radius * (angle / 360);
      const innerArcLength = 2 * Math.PI * (radius - thickness) * (angle / 360);
      // Compute the number of cuts by dividing the board thickness arc
      // length by the kerf width and rounding up.  This matches the logic
      // used on the original Blocklayer calculator.
      const cuts = Math.ceil((outerArcLength - innerArcLength) / kerf);
      // Determine the spacing between cut centres (D) and the wood width
      // remaining between kerfs (r).  When cuts start from the board ends
      // (curveFromEnds checked), there is an extra spacing at each end, so
      // there are (cuts + 1) spaces.  Otherwise there are (cuts - 1) spaces.
      let spacing, woodWidth, startPos;
      if (curveFromEnds) {
        const spaces = cuts + 1;
        spacing = (outerArcLength + kerf) / spaces;
        woodWidth = spacing - kerf;
        // First cut centre is offset by half a spacing beyond the first
        // wood-width section
        startPos = woodWidth + kerf / 2;
      } else {
        const spaces = cuts - 1;
        spacing = outerArcLength / spaces;
        woodWidth = spacing - kerf;
        // First cut centre is at the start of the board
        startPos = 0;
      }
      // Assemble an array of cut centre positions (in millimetres) along the
      // length of the board.  These positions are used for drawing the
      // diagrams and for labelling.  Only positions for actual cuts are
      // included – end spacings are ignored for labelling purposes.
      const positions = [];
      for (let i = 0; i < cuts; i++) {
        positions.push(startPos + i * spacing);
      }
      // Prepare a result string summarising the calculation.  Present the
      // spacing and wood-width values to one decimal place for clarity.
      const resultStr = `${cuts} cuts of ${kerf.toFixed(2)} mm @ ${spacing.toFixed(1)} mm centres with ${woodWidth.toFixed(1)} mm wood width between cuts.`;
      resultsElem.innerHTML += `<p><strong>${resultStr}</strong></p>`;
      // Draw the diagrams using the computed positions and arc length.
      drawStraightDiagram(radius, angle, kerf, thickness, minThick, positions, outerArcLength);
      drawCurvedDiagram(radius, angle, kerf, thickness, minThick, positions, outerArcLength, curveFromEnds);
    }
// Ensure clicking the button doesn't submit a form or reload the page
document.getElementById('calculate').addEventListener('click', function(e) {
      e.preventDefault();
      calculate();
    });

    /**
     * Draw the straight (top view) diagram of kerf cuts on a board.
     * This draws a horizontal board with vertical lines indicating cuts and labels each cut.
     *
     * @param {number} radius - Curve radius in millimetres.
     * @param {number} angle - Sweep angle in degrees.
     * @param {number} kerf - Kerf width (blade thickness) in millimetres.
     * @param {number} thickness - Board thickness in millimetres.
     * @param {number} minThick - Minimum remaining thickness after cut (mm).
     * @param {number} cuts - Number of cuts.
     * @param {boolean} curveFromEnds - True if kerfs start from board ends.
     * @param {number} D - Centre spacing between cut centres (mm).
     */
    function drawStraightDiagram(radius, angle, kerf, thickness, minThick, positions, arcLength) {
      const canvas = document.getElementById('straightDiagram');
      if (!canvas) return;
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      // Margins and dimensions for the board
      const marginX = 40;
      const boardWidthPx = canvas.width - 2 * marginX;
      const boardTopPx = 40;
      const boardHeightPx = 50;
      const boardBottomPx = boardTopPx + boardHeightPx;
      // Scale mm to pixels along the board length
      const scale = boardWidthPx / arcLength;
      // Draw the board background: white fill and black outline
      ctx.fillStyle = '#ffffff';
      ctx.strokeStyle = '#000000';
      ctx.lineWidth = 1.5;
      ctx.fillRect(marginX, boardTopPx, boardWidthPx, boardHeightPx);
      ctx.strokeRect(marginX, boardTopPx, boardWidthPx, boardHeightPx);
      // Shade the removed wood (kerf depth) region
      const cutDepthMm = thickness - minThick;
      const cutDepthRatio = cutDepthMm / thickness;
      const cutDepthPx = boardHeightPx * cutDepthRatio;
      ctx.fillStyle = '#dddddd';
      ctx.fillRect(marginX, boardTopPx, boardWidthPx, cutDepthPx);
      // Draw dimension annotation once above the board
      const arrowY = boardTopPx - 20;
      // Main dimension line
      ctx.strokeStyle = '#000000';
      ctx.beginPath();
      ctx.moveTo(marginX, arrowY);
      ctx.lineTo(marginX + boardWidthPx, arrowY);
      ctx.stroke();
      // Arrowheads
      const arrowSize = 6;
      ctx.beginPath();
      ctx.moveTo(marginX, arrowY);
      ctx.lineTo(marginX + arrowSize, arrowY - 4);
      ctx.lineTo(marginX + arrowSize, arrowY + 4);
      ctx.closePath();
      ctx.fill();
      ctx.beginPath();
      ctx.moveTo(marginX + boardWidthPx, arrowY);
      ctx.lineTo(marginX + boardWidthPx - arrowSize, arrowY - 4);
      ctx.lineTo(marginX + boardWidthPx - arrowSize, arrowY + 4);
      ctx.closePath();
      ctx.fill();
      // Labels for total arc length and start/end
      ctx.fillStyle = '#000000';
      ctx.font = '12px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'bottom';
      ctx.fillText(`${Math.round(arcLength)} mm`, marginX + boardWidthPx / 2, arrowY - 2);
      ctx.textAlign = 'left';
      ctx.fillText('Start Curve', marginX, arrowY - 2);
      ctx.textAlign = 'right';
      ctx.fillText('End Curve', marginX + boardWidthPx, arrowY - 2);
      // Prepare styles for kerf shading and lines
      ctx.fillStyle = '#bbbbbb';
      ctx.strokeStyle = '#000000';
      ctx.lineWidth = 1;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'top';
      ctx.font = '12px Arial';
      // Draw each kerf cut
      for (let i = 0; i < positions.length; i++) {
        const dist = positions[i];
        if (dist > arcLength) continue;
        const xCenterPx = marginX + dist * scale;
        const kerfPx = kerf * scale;
        // Shade the kerf gap (top portion only)
        ctx.fillRect(xCenterPx - kerfPx / 2, boardTopPx, kerfPx, cutDepthPx);
        // Draw the cut line
        ctx.beginPath();
        ctx.moveTo(xCenterPx, boardTopPx);
        ctx.lineTo(xCenterPx, boardBottomPx);
        ctx.stroke();
        // Label the distance along the board in millimetres.  Round to the nearest
        // integer so the numbers correspond to positions along the board in mm.
        const labelY = boardBottomPx + 8;
        ctx.fillStyle = '#000000';
        const distMm = Math.round(dist);
        ctx.fillText(distMm.toString(), xCenterPx, labelY);
      }
    }

    /**
     * Draw the curved view diagram of kerf cuts on a board.
     * This renders a curved board segment with radial cut lines and wedge-shaped kerfs.
     *
     * @param {number} radius - Curve radius (mm).
     * @param {number} angle - Sweep angle (degrees).
     * @param {number} kerf - Kerf width (mm).
     * @param {number} thickness - Board thickness (mm).
     * @param {number} minThick - Minimum remaining thickness after kerf (mm).
     * @param {number} cuts - Number of cuts.
     * @param {boolean} curveFromEnds - Whether kerfs start from board ends.
     * @param {number} D - Centre spacing (mm).
     */
    function drawCurvedDiagram(radius, angle, kerf, thickness, minThick, positions, arcLength, curveFromEnds) {
      const canvas = document.getElementById('curvedDiagram');
      if (!canvas) return;
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      // Total sweep in radians
      const totalAngleRad = angle * Math.PI / 180;
      // Define start and end angles such that the curve is drawn concave
      // downward in the canvas (start at 90° + half sweep, end at 90° - half sweep)
      const halfSweep = totalAngleRad / 2;
      const startAngle = Math.PI / 2 + halfSweep;
      const endAngle = Math.PI / 2 - halfSweep;
      const outerR = radius;
      const innerR = radius - (thickness - minThick);
      // Determine the horizontal and vertical extents of the curved board to
      // compute a uniform scale that fits within the canvas margins.  The
      // horizontal span equals 2 * R * sin(half sweep).  The vertical span
      // equals the distance from the top of the outer arc to the bottom of
      // the inner arc.
      const spanMm = 2 * outerR * Math.sin(halfSweep);
      const marginX = 40;
      const marginY = 20;
      const widthPx = canvas.width - 2 * marginX;
      const heightPx = canvas.height - 2 * marginY;
      const totalHeightMm = 2 * outerR - innerR;
      const scale = Math.min(widthPx / spanMm, heightPx / totalHeightMm);
      const centerX = canvas.width / 2;
      const centerY = marginY + outerR * scale;
      // Draw the board outline (outer arc -> radial -> inner arc -> radial)
      ctx.beginPath();
      ctx.moveTo(
        centerX + outerR * scale * Math.cos(startAngle),
        centerY + outerR * scale * Math.sin(startAngle)
      );
      ctx.arc(centerX, centerY, outerR * scale, startAngle, endAngle, false);
      ctx.lineTo(
        centerX + innerR * scale * Math.cos(endAngle),
        centerY + innerR * scale * Math.sin(endAngle)
      );
      ctx.arc(centerX, centerY, innerR * scale, endAngle, startAngle, true);
      ctx.closePath();
      ctx.fillStyle = '#ffffff';
      ctx.strokeStyle = '#000000';
      ctx.lineWidth = 1.5;
      ctx.fill();
      ctx.stroke();
      // Precompute a constant half‑wedge angle based on the mean spacing between
      // cuts.  We use 40% of the spacing to ensure the wedges are large
      // enough to be visible.  This factor can be tuned for aesthetics.
      const anglePerCut = totalAngleRad / positions.length;
      const halfWedgeAngle = anglePerCut * 0.4;
      ctx.font = '14px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      for (let i = 0; i < positions.length; i++) {
        const dist = positions[i];
        if (dist > arcLength) continue;
        const frac = dist / arcLength;
        // Central angle for this cut (reverse direction: startAngle -> endAngle).
        const theta = startAngle - frac * totalAngleRad;
        // Determine the left and right edges of the wedge around the centre.
        const leftEdge = theta - halfWedgeAngle;
        const rightEdge = theta + halfWedgeAngle;
        // Coordinates of the apex at the inner radius
        const apexX = centerX + innerR * scale * Math.cos(theta);
        const apexY = centerY + innerR * scale * Math.sin(theta);
        // Coordinates of the base of the wedge on the outer radius
        const baseLeftX = centerX + outerR * scale * Math.cos(leftEdge);
        const baseLeftY = centerY + outerR * scale * Math.sin(leftEdge);
        const baseRightX = centerX + outerR * scale * Math.cos(rightEdge);
        const baseRightY = centerY + outerR * scale * Math.sin(rightEdge);
        // Shade the kerf wedge with a mid‑tone grey so it stands out
        ctx.fillStyle = '#dddddd';
        ctx.beginPath();
        ctx.moveTo(apexX, apexY);
        ctx.lineTo(baseLeftX, baseLeftY);
        ctx.lineTo(baseRightX, baseRightY);
        ctx.closePath();
        ctx.fill();
        // Draw the radial boundary lines of the wedge
        ctx.strokeStyle = '#888888';
        ctx.beginPath();
        ctx.moveTo(apexX, apexY);
        ctx.lineTo(baseLeftX, baseLeftY);
        ctx.moveTo(apexX, apexY);
        ctx.lineTo(baseRightX, baseRightY);
        ctx.stroke();
        // Draw the central cut line in solid black
        const outerX = centerX + outerR * scale * Math.cos(theta);
        const outerY = centerY + outerR * scale * Math.sin(theta);
        ctx.strokeStyle = '#000000';
        ctx.beginPath();
        ctx.moveTo(apexX, apexY);
        ctx.lineTo(outerX, outerY);
        ctx.stroke();
        // Label each cut number along the inner arc between the inner and outer radii
        const labelRadius = (innerR + outerR) / 2;
        const labelX = centerX + labelRadius * scale * Math.cos(theta);
        const labelY = centerY + labelRadius * scale * Math.sin(theta);
        ctx.fillStyle = '#000000';
        ctx.fillText((i + 1).toString(), labelX, labelY);
      }
    }

    // The drawDiagram function has been replaced with two more detailed diagram
    // functions defined below: drawStraightDiagram and drawCurvedDiagram.
  </script>
</body>
</html>
